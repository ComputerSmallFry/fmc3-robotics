# 集成自定义硬件

本教程将说明如何将你自己的机器人设计集成到LeRobot生态系统中，并使用我们所有的工具（数据采集、控制流程、策略训练和推理）。

为此，我们在LeRobot中提供了[`Robot`](https://github.com/huggingface/lerobot/blob/main/src/lerobot/robots/robot.py)基类，它定义了物理机器人集成的标准接口。让我们看看如何实现它。

## 前置条件

- 你自己的机器人，需要暴露通信接口（例如串口、CAN、TCP）
- 能够以编程方式读取传感器数据和发送电机命令的方法，例如制造商的SDK或API，或你自己的协议实现
- 在你的环境中安装LeRobot。参考我们的[安装指南](./installation)

## 选择你的电机

如果你使用Feetech或Dynamixel电机，LeRobot提供了内置的总线接口：

- [`FeetechMotorsBus`](https://github.com/huggingface/lerobot/blob/main/src/lerobot/motors/feetech/feetech.py) – 用于控制Feetech舵机
- [`DynamixelMotorsBus`](https://github.com/huggingface/lerobot/blob/main/src/lerobot/motors/dynamixel/dynamixel.py) – 用于控制Dynamixel舵机

请参考[`MotorsBus`](https://github.com/huggingface/lerobot/blob/main/src/lerobot/motors/motors_bus.py)抽象类来了解其API。
关于如何使用的好例子，可以查看我们自己的[SO101 follower实现](https://github.com/huggingface/lerobot/blob/main/src/lerobot/robots/so_follower/so101_follower/so101_follower.py)

如果兼容就使用这些。否则，你需要找到或编写一个Python接口（本教程不涵盖）：

- 找一个现有的Python SDK（或使用C/C++绑定）
- 或实现一个基本的通信包装器（例如，通过pyserial、socket或CANopen）

你并不孤单——许多社区贡献使用自定义板或固件！

对于Feetech和Dynamixel，我们目前支持这些舵机：
- Feetech：
  - STS & SMS系列（协议0）：`sts3215`、`sts3250`、`sm8512bl`
  - SCS系列（协议1）：`scs0009`
- Dynamixel（仅协议2.0）：`xl330-m077`、`xl330-m288`、`xl430-w250`、`xm430-w350`、`xm540-w270`、`xc430-w150`

如果你使用的Feetech或Dynamixel舵机不在此列表中，可以在[Feetech表](https://github.com/huggingface/lerobot/blob/main/src/lerobot/motors/feetech/tables.py)或[Dynamixel表](https://github.com/huggingface/lerobot/blob/main/src/lerobot/motors/dynamixel/tables.py)中添加。根据型号，这需要你添加特定型号的信息。不过在大多数情况下，不需要添加太多内容。

在接下来的章节中，我们将使用`FeetechMotorsBus`作为示例的电机接口。如有必要，请替换并适配到你的电机。

## 步骤1：继承`Robot`接口

首先需要指定配置类和机器人的字符串标识符（`name`）。如果你的机器人有需要轻松更改的特殊需求，应该放在这里（例如端口/地址、波特率）。

这里，我们将为机器人添加端口名称和一个默认相机：

```python
from dataclasses import dataclass, field

from lerobot.cameras import CameraConfig
from lerobot.cameras.opencv import OpenCVCameraConfig
from lerobot.robots import RobotConfig

@RobotConfig.register_subclass("my_cool_robot")
@dataclass
class MyCoolRobotConfig(RobotConfig):
    port: str
    cameras: dict[str, CameraConfig] = field(
        default_factory={
            "cam_1": OpenCVCameraConfig(
                index_or_path=2,
                fps=30,
                width=480,
                height=640,
            ),
        }
    )
```

参考[相机教程](./cameras)了解如何检测和添加相机。

接下来，我们将创建继承自`Robot`的实际机器人类。这个抽象类定义了一个契约，你必须遵循它才能让你的机器人与LeRobot的其他工具一起使用。

这里我们将创建一个带有一个相机的简单5自由度机器人。它可以是一个简单的机械臂，但请注意`Robot`抽象类不对机器人的形态做任何假设。你可以在设计新机器人时充分发挥想象力！

```python
from lerobot.cameras import make_cameras_from_configs
from lerobot.motors import Motor, MotorNormMode
from lerobot.motors.feetech import FeetechMotorsBus
from lerobot.robots import Robot

class MyCoolRobot(Robot):
    config_class = MyCoolRobotConfig
    name = "my_cool_robot"

    def __init__(self, config: MyCoolRobotConfig):
        super().__init__(config)
        self.bus = FeetechMotorsBus(
            port=self.config.port,
            motors={
                "joint_1": Motor(1, "sts3250", MotorNormMode.RANGE_M100_100),
                "joint_2": Motor(2, "sts3215", MotorNormMode.RANGE_M100_100),
                "joint_3": Motor(3, "sts3215", MotorNormMode.RANGE_M100_100),
                "joint_4": Motor(4, "sts3215", MotorNormMode.RANGE_M100_100),
                "joint_5": Motor(5, "sts3215", MotorNormMode.RANGE_M100_100),
            },
            calibration=self.calibration,
        )
        self.cameras = make_cameras_from_configs(config.cameras)
```

## 步骤2：定义观测和动作特征

这两个属性定义了机器人与使用它的工具（如数据采集或学习流程）之间的_接口契约_。

> **警告**
> 注意，即使机器人尚未连接，这些属性也必须是可调用的，因此避免依赖运行时硬件状态来定义它们。

### `observation_features`

此属性应返回一个字典，描述机器人传感器输出的结构。键与`get_observation()`返回的内容匹配，值描述形状（对于数组/图像）或类型（对于简单值）。

我们的5自由度机械臂带一个相机的示例：

```python
@property
def _motors_ft(self) -> dict[str, type]:
    return {
        "joint_1.pos": float,
        "joint_2.pos": float,
        "joint_3.pos": float,
        "joint_4.pos": float,
        "joint_5.pos": float,
    }

@property
def _cameras_ft(self) -> dict[str, tuple]:
    return {
        cam: (self.cameras[cam].height, self.cameras[cam].width, 3) for cam in self.cameras
    }

@property
def observation_features(self) -> dict:
    return {**self._motors_ft, **self._cameras_ft}
```

在这种情况下，观测由一个简单的字典组成，存储每个电机的位置和一个相机图像。

### `action_features`

此属性描述机器人通过`send_action()`期望的命令。同样，键必须与预期的输入格式匹配，值定义每个命令的形状/类型。

这里，我们简单地使用与`observation_features`相同的关节本体感觉特征（`self._motors_ft`）：发送的动作将简单地是每个电机的目标位置。

```python
def action_features(self) -> dict:
    return self._motors_ft
```

## 步骤3：处理连接和断开连接

这些方法应处理与硬件的通信打开和关闭（例如串口、CAN接口、USB设备、相机）。

### `is_connected`

此属性应简单地反映与机器人硬件的通信已建立。当此属性为`True`时，应该可以使用`get_observation()`和`send_action()`读写硬件。

```python
@property
def is_connected(self) -> bool:
    return self.bus.is_connected and all(cam.is_connected for cam in self.cameras.values())
```

### `connect()`

此方法应建立与硬件的通信。此外，如果你的机器人需要校准且尚未校准，默认情况下应启动校准程序。如果你的机器人需要一些特定配置，也应该在这里调用。

```python
def connect(self, calibrate: bool = True) -> None:
    self.bus.connect()
    if not self.is_calibrated and calibrate:
        self.calibrate()

    for cam in self.cameras.values():
        cam.connect()

    self.configure()
```

### `disconnect()`

此方法应优雅地终止与硬件的通信：释放任何相关资源（线程或进程）、关闭端口等。

这里，我们已经在`MotorsBus`和`Camera`类中处理了这个问题，所以我们只需要调用它们自己的`disconnect()`方法：

```python
def disconnect(self) -> None:
    self.bus.disconnect()
    for cam in self.cameras.values():
        cam.disconnect()
```

## 步骤4：支持校准和配置

LeRobot支持自动保存和加载校准数据。这对于关节偏移、零位或传感器对齐很有用。

> 注意，根据你的硬件，这可能不适用。如果是这种情况，你可以简单地将这些方法留空：

```python
@property
def is_calibrated(self) -> bool:
    return True

def calibrate(self) -> None:
    pass
```

### `is_calibrated`

这应该反映你的机器人是否已加载所需的校准。

```python
@property
def is_calibrated(self) -> bool:
    return self.bus.is_calibrated
```

### `calibrate()`

校准的目标有两个：

- 了解每个电机的物理运动范围，以便仅在此范围内发送命令
- 将原始电机位置归一化为合理的连续值（例如百分比、度数），而不是依赖于特定电机的任意离散值，这些值无法在其他地方复制

它应该实现校准逻辑（如果相关）并更新`self.calibration`字典。如果你使用Feetech或Dynamixel电机，我们的总线接口已经包含了帮助实现这一点的方法。

```python
def calibrate(self) -> None:
    self.bus.disable_torque()
    for motor in self.bus.motors:
        self.bus.write("Operating_Mode", motor, OperatingMode.POSITION.value)

    input(f"将{self}移动到其运动范围的中间位置并按ENTER....")
    homing_offsets = self.bus.set_half_turn_homings()

    print(
        "依次移动所有关节通过其整个运动范围。\n正在记录位置。按ENTER停止..."
    )
    range_mins, range_maxes = self.bus.record_ranges_of_motion()

    self.calibration = {}
    for motor, m in self.bus.motors.items():
        self.calibration[motor] = MotorCalibration(
            id=m.id,
            drive_mode=0,
            homing_offset=homing_offsets[motor],
            range_min=range_mins[motor],
            range_max=range_maxes[motor],
        )

    self.bus.write_calibration(self.calibration)
    self._save_calibration()
    print("校准已保存到", self.calibration_fpath)
```

### `configure()`

使用此方法为硬件设置任何配置（舵机控制模式、控制器增益等）。这通常应在连接时运行，并且应该是幂等的。

```python
def configure(self) -> None:
    with self.bus.torque_disabled():
        self.bus.configure_motors()
        for motor in self.bus.motors:
            self.bus.write("Operating_Mode", motor, OperatingMode.POSITION.value)
            self.bus.write("P_Coefficient", motor, 16)
            self.bus.write("I_Coefficient", motor, 0)
            self.bus.write("D_Coefficient", motor, 32)
```

## 步骤5：实现传感器读取和动作发送

这些是最重要的运行时函数：核心I/O循环。

### `get_observation()`

从机器人返回传感器值的字典。这些通常包括电机状态、相机帧、各种传感器等。在LeRobot框架中，这些观测将被输入到策略中以预测要采取的动作。字典键和结构必须与`observation_features`匹配。

```python
def get_observation(self) -> dict[str, Any]:
    if not self.is_connected:
        raise ConnectionError(f"{self}未连接。")

    # 读取机械臂位置
    obs_dict = self.bus.sync_read("Present_Position")
    obs_dict = {f"{motor}.pos": val for motor, val in obs_dict.items()}

    # 从相机捕获图像
    for cam_key, cam in self.cameras.items():
        obs_dict[cam_key] = cam.async_read()

    return obs_dict
```

### `send_action()`

接受一个与`action_features`匹配的字典，并将其发送到硬件。你可以添加安全限制（裁剪、平滑）并返回实际发送的内容。

为简单起见，我们在这个示例中不会对动作进行任何修改。

```python
def send_action(self, action: dict[str, Any]) -> dict[str, Any]:
    goal_pos = {key.removesuffix(".pos"): val for key, val in action.items()}

    # 将目标位置发送到机械臂
    self.bus.sync_write("Goal_Position", goal_pos)

    return action
```

## 添加遥操作器

为了实现遥操作设备，我们还提供了[`Teleoperator`](https://github.com/huggingface/lerobot/blob/main/src/lerobot/teleoperators/teleoperator.py)基类。这个类与`Robot`基类非常相似，也不对形态做任何假设。

主要区别在于I/O函数：遥操作器允许你通过`get_action`产生动作，并可以通过`send_feedback`接收反馈动作。反馈可以是遥操作设备上任何可控制的东西，可以帮助控制者理解发送动作的后果。想想主臂上的运动/力反馈，游戏手柄控制器上的振动等。要实现遥操作器，你可以遵循同样的教程并针对这两个方法进行调整。

## 使用你自己的`LeRobot`设备 🔌

你可以通过创建一个单独的、可安装的Python包来轻松扩展`lerobot`，添加你自己的自定义硬件——无论是相机、机器人还是遥操作设备。如果你遵循一些简单的约定，`lerobot`命令行工具（如`lerobot-teleop`和`lerobot-record`）将**自动发现并集成你的创作**，无需对`lerobot`源代码进行任何更改。

本指南概述了你的插件必须遵循的约定。

### 4个核心约定

为确保你的自定义设备可被发现，你必须遵守以下四条规则。

#### 1. 创建具有特定前缀的可安装包

你的项目必须是一个标准的、可安装的Python包。关键是，你的包名称（在`pyproject.toml`或`setup.py`中定义）必须以以下前缀之一开头：

- `lerobot_robot_` 用于机器人
- `lerobot_camera_` 用于相机
- `lerobot_teleoperator_` 用于遥操作设备

这个前缀系统是`lerobot`在Python环境中自动找到你的插件的方式。

#### 2. 遵循`SomethingConfig`/`Something`命名模式

你的设备实现类必须以其配置类命名，只需删除`Config`后缀。

- **配置类：** `MyAwesomeTeleopConfig`
- **设备类：** `MyAwesomeTeleop`

#### 3. 将文件放在可预测的结构中

设备类（`MyAwesomeTeleop`）必须位于相对于其配置类（`MyAwesomeTeleopConfig`）可预测的模块中。`lerobot`将自动在这些位置搜索：

- 在与配置类**相同的模块**中
- 在以设备命名的**子模块**中（例如`my_awesome_teleop.py`）

推荐且最简单的结构是将它们放在同一目录中的单独、清晰命名的文件中。

#### 4. 在`__init__.py`中暴露类

你的包的`__init__.py`文件应该导入并暴露配置类和设备类，使它们易于访问。

### 综合示例

让我们创建一个名为`my_awesome_teleop`的新遥操作器。

#### 目录结构

项目文件夹应该如下所示。包名`lerobot_teleoperator_my_awesome_teleop`遵循**约定#1**。

```
lerobot_teleoperator_my_awesome_teleop/
├── pyproject.toml # (或setup.py) 将lerobot列为依赖项
└── lerobot_teleoperator_my_awesome_teleop/
    ├── __init__.py
    ├── config_my_awesome_teleop.py
    └── my_awesome_teleop.py
```

#### 文件内容

- **`config_my_awesome_teleop.py`**：定义配置类。注意`Config`后缀（**约定#2**）。

  ```python
  from dataclasses import dataclass

  from lerobot.teleoperators.config import TeleoperatorConfig

  @TeleoperatorConfig.register_subclass("my_awesome_teleop")
  @dataclass
  class MyAwesomeTeleopConfig(TeleoperatorConfig):
      # 你的配置字段放在这里
      port: str = "192.168.1.1"
  ```

- **`my_awesome_teleop.py`**：实现设备。类名`MyAwesomeTeleop`与其配置类名匹配（**约定#2**）。此文件结构遵守**约定#3**。

  ```python
  from lerobot.teleoperators.teleoperator import Teleoperator

  from .config_my_awesome_teleop import MyAwesomeTeleopConfig

  class MyAwesomeTeleop(Teleoperator):
      config_class = MyAwesomeTeleopConfig
      name = "my_awesome_teleop"

      def __init__(self, config: MyAwesomeTeleopConfig):
          super().__init__(config)
          self.config = config

      # 你的设备逻辑（例如connect）放在这里
  ```

- **`__init__.py`**：暴露关键类（**约定#4**）。

  ```python
  from .config_my_awesome_teleop import MyAwesomeTeleopConfig
  from .my_awesome_teleop import MyAwesomeTeleop
  ```

### 安装和使用

1. **在Python环境中安装新插件。** 你可以使用`pip`的可编辑模式或从PyPi安装本地插件包。

   ```bash
   # 本地安装
   # 导航到插件的根目录并安装
   cd lerobot_teleoperator_my_awesome_teleop
   pip install -e .

   # 从PyPi安装
   pip install lerobot_teleoperator_my_awesome_teleop
   ```

2. **直接从命令行使用。** 现在，你可以通过引用其类型来使用自定义设备。

   ```bash
   lerobot-teleoperate --teleop.type=my_awesome_teleop \
   # 其他参数
   ```

就是这样！你的自定义设备现在已完全集成。

### 寻找示例？

查看社区的这两个包：

- https://github.com/SpesRobotics/lerobot-robot-xarm
- https://github.com/SpesRobotics/lerobot-teleoperator-teleop

## 总结

一旦你的机器人类完成，你就可以利用LeRobot生态系统：

- 使用可用的遥操作器控制机器人或直接集成你的遥操作设备
- 记录训练数据并可视化
- 将其集成到强化学习或模仿学习流程中

如有任何问题，欢迎在我们的[Discord](https://discord.gg/s3KuuzsPFb)上向社区寻求帮助 🤗

